//==============================================================================
// 简化版Aurora发送器（纯逻辑实现）
// 功能：将16bit数据封装成Aurora帧并发送
// 包含：8B/10B编码、帧头/尾、CRC校验
//==============================================================================

module aurora_tx_simple (
    input  wire        clk,              // 系统时钟
    input  wire        rst_n,            // 复位
    
    // 输入接口（来自1553B）
    input  wire [15:0] data_in,          // 16bit输入数据
    input  wire        data_valid,       // 数据有效
    
    // 高速串行输出接口
    output reg         tx_p,             // 差分输出正
    output reg         tx_n,             // 差分输出负
    
    // 状态
    output wire        busy,             // 忙碌标志
    output wire [7:0]  state_debug       // 状态调试
);

//==============================================================================
// Aurora协议简化说明：
// 1. 帧格式：[帧头] [数据] [CRC] [帧尾]
// 2. 帧头：K28.5 (K字符，用于同步)
// 3. 数据：用户数据（经过8B/10B编码）
// 4. CRC：简化的校验
// 5. 帧尾：K28.5
//==============================================================================

//==============================================================================
// 状态机定义
//==============================================================================
localparam IDLE         = 4'd0;   // 空闲
localparam SEND_HEADER  = 4'd1;   // 发送帧头
localparam SEND_DATA_H  = 4'd2;   // 发送数据高字节
localparam SEND_DATA_L  = 4'd3;   // 发送数据低字节
localparam SEND_CRC     = 4'd4;   // 发送CRC
localparam SEND_TAIL    = 4'd5;   // 发送帧尾
localparam SERIALIZE    = 4'd6;   // 串行化输出

//==============================================================================
// K字符定义（8B/10B特殊字符）
//==============================================================================
// K28.5: 常用的逗号字符，用于帧同步
localparam K28_5 = 8'hBC;  // K28.5

//==============================================================================
// 内部信号
//==============================================================================
reg [3:0]  state;
reg [3:0]  next_state;

// 数据缓冲
reg [15:0] data_buffer;
reg [7:0]  current_byte;
reg        current_is_k;      // 当前字节是否为K字符

// 8B/10B编码器接口
wire [9:0] enc_data_10bit;
wire       enc_valid;
wire       enc_rd;

// 串行化
reg [9:0]  shift_reg;         // 10bit移位寄存器
reg [3:0]  bit_counter;       // 位计数器
reg        serializing;

// CRC
reg [7:0]  crc_value;

//==============================================================================
// 状态机 - 时序逻辑
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= IDLE;
    else
        state <= next_state;
end

//==============================================================================
// 状态机 - 组合逻辑
//==============================================================================
always @(*) begin
    next_state = state;
    
    case (state)
        IDLE: begin
            if (data_valid)
                next_state = SEND_HEADER;
        end
        
        SEND_HEADER: begin
            if (!serializing)
                next_state = SERIALIZE;
        end
        
        SERIALIZE: begin
            if (bit_counter == 4'd9) begin  // 发送完10bit
                case (state)
                    SEND_HEADER:  next_state = SEND_DATA_H;
                    SEND_DATA_H:  next_state = SEND_DATA_L;
                    SEND_DATA_L:  next_state = SEND_CRC;
                    SEND_CRC:     next_state = SEND_TAIL;
                    SEND_TAIL:    next_state = IDLE;
                    default:      next_state = IDLE;
                endcase
            end
        end
        
        SEND_DATA_H: begin
            if (!serializing)
                next_state = SERIALIZE;
        end
        
        SEND_DATA_L: begin
            if (!serializing)
                next_state = SERIALIZE;
        end
        
        SEND_CRC: begin
            if (!serializing)
                next_state = SERIALIZE;
        end
        
        SEND_TAIL: begin
            if (!serializing)
                next_state = SERIALIZE;
        end
        
        default: next_state = IDLE;
    endcase
end

//==============================================================================
// 数据准备
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        data_buffer    <= 16'd0;
        current_byte   <= 8'd0;
        current_is_k   <= 1'b0;
        crc_value      <= 8'd0;
    end else begin
        case (state)
            IDLE: begin
                if (data_valid) begin
                    data_buffer <= data_in;
                    crc_value   <= data_in[15:8] ^ data_in[7:0];  // 简化CRC
                end
            end
            
            SEND_HEADER: begin
                current_byte <= K28_5;
                current_is_k <= 1'b1;  // K字符
            end
            
            SEND_DATA_H: begin
                current_byte <= data_buffer[15:8];
                current_is_k <= 1'b0;  // 数据字符
            end
            
            SEND_DATA_L: begin
                current_byte <= data_buffer[7:0];
                current_is_k <= 1'b0;
            end
            
            SEND_CRC: begin
                current_byte <= crc_value;
                current_is_k <= 1'b0;
            end
            
            SEND_TAIL: begin
                current_byte <= K28_5;
                current_is_k <= 1'b1;  // K字符
            end
        endcase
    end
end

//==============================================================================
// 8B/10B 编码器实例化
//==============================================================================
encoder_8b10b u_encoder (
    .clk          (clk),
    .rst_n        (rst_n),
    .data_in      (current_byte),
    .k_in         (current_is_k),
    .valid_in     (state == SEND_HEADER || state == SEND_DATA_H || 
                   state == SEND_DATA_L || state == SEND_CRC || 
                   state == SEND_TAIL),
    .data_out     (enc_data_10bit),
    .valid_out    (enc_valid),
    .running_disp (enc_rd)
);

//==============================================================================
// 串行化：10bit → 1bit串行输出
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg   <= 10'd0;
        bit_counter <= 4'd0;
        serializing <= 1'b0;
        tx_p        <= 1'b1;
        tx_n        <= 1'b0;
    end else begin
        if (enc_valid && !serializing) begin
            // 加载新的10bit数据
            shift_reg   <= enc_data_10bit;
            bit_counter <= 4'd0;
            serializing <= 1'b1;
        end else if (serializing) begin
            // 串行输出（LSB first）
            tx_p <= shift_reg[0];
            tx_n <= ~shift_reg[0];
            
            shift_reg   <= {1'b0, shift_reg[9:1]};  // 右移
            bit_counter <= bit_counter + 1'b1;
            
            if (bit_counter == 4'd9) begin
                serializing <= 1'b0;
            end
        end else begin
            // 空闲状态：发送空闲模式（交替0和1）
            tx_p <= ~tx_p;
            tx_n <= ~tx_n;
        end
    end
end

//==============================================================================
// 输出
//==============================================================================
assign busy = (state != IDLE);
assign state_debug = {4'd0, state};

endmodule
//==============================================================================
// 真正的 8B/10B 编码器
// 功能：将8bit数据编码成10bit数据，用于高速串行传输
// 标准：IEEE 802.3 (Clause 36)
//==============================================================================

module encoder_8b10b (
    input  wire       clk,
    input  wire       rst_n,
    
    // 输入接口 (8bit)
    input  wire [7:0] data_in,        // 8bit输入数据
    input  wire       k_in,           // K字符标志 (1=控制字符, 0=数据字符)
    input  wire       valid_in,       // 输入有效信号
    
    // 输出接口 (10bit)
    output reg  [9:0] data_out,       // 10bit编码输出
    output reg        valid_out,      // 输出有效信号
    
    // 状态
    output wire       running_disp    // 当前RD (Running Disparity)
);

//==============================================================================
// 8B/10B编码原理：
// - 将8bit数据分成两部分：5bit (EDCBA) + 3bit (HGF)
// - 5bit编码成6bit，3bit编码成4bit
// - 维护Running Disparity (RD)以保证DC平衡
//==============================================================================

//==============================================================================
// 内部信号
//==============================================================================
reg rd;  // Running Disparity: 0=负, 1=正

// 输入数据分解
wire [4:0] data_5b;  // EDCBA
wire [2:0] data_3b;  // HGF

assign data_5b = data_in[4:0];
assign data_3b = data_in[7:5];

// 编码输出
reg [5:0] code_6b;
reg [3:0] code_4b;

//==============================================================================
// 5B/6B 编码表（简化版，仅实现常用编码）
//==============================================================================
always @(*) begin
    case (data_5b)
        // D.0-D.7
        5'b00000: code_6b = rd ? 6'b011000 : 6'b100111;  // D.0
        5'b00001: code_6b = rd ? 6'b100010 : 6'b011101;  // D.1
        5'b00010: code_6b = rd ? 6'b010010 : 6'b101101;  // D.2
        5'b00011: code_6b = 6'b110001;                   // D.3
        5'b00100: code_6b = rd ? 6'b001010 : 6'b110101;  // D.4
        5'b00101: code_6b = 6'b101001;                   // D.5
        5'b00110: code_6b = 6'b011001;                   // D.6
        5'b00111: code_6b = rd ? 6'b000111 : 6'b111000;  // D.7
        
        // D.8-D.15
        5'b01000: code_6b = rd ? 6'b000110 : 6'b111001;  // D.8
        5'b01001: code_6b = 6'b100101;                   // D.9
        5'b01010: code_6b = 6'b010101;                   // D.10
        5'b01011: code_6b = 6'b110100;                   // D.11
        5'b01100: code_6b = 6'b001101;                   // D.12
        5'b01101: code_6b = 6'b101100;                   // D.13
        5'b01110: code_6b = 6'b011100;                   // D.14
        5'b01111: code_6b = rd ? 6'b101000 : 6'b010111;  // D.15
        
        // D.16-D.23
        5'b10000: code_6b = rd ? 6'b100100 : 6'b011011;  // D.16
        5'b10001: code_6b = 6'b100011;                   // D.17
        5'b10010: code_6b = 6'b010011;                   // D.18
        5'b10011: code_6b = 6'b110010;                   // D.19
        5'b10100: code_6b = 6'b001011;                   // D.20
        5'b10101: code_6b = 6'b101010;                   // D.21
        5'b10110: code_6b = 6'b011010;                   // D.22
        5'b10111: code_6b = rd ? 6'b000101 : 6'b111010;  // D.23
        
        // D.24-D.31
        5'b11000: code_6b = rd ? 6'b001100 : 6'b110011;  // D.24
        5'b11001: code_6b = 6'b100110;                   // D.25
        5'b11010: code_6b = 6'b010110;                   // D.26
        5'b11011: code_6b = rd ? 6'b110110 : 6'b001001;  // D.27
        5'b11100: code_6b = 6'b001110;                   // D.28
        5'b11101: code_6b = rd ? 6'b101110 : 6'b010001;  // D.29
        5'b11110: code_6b = rd ? 6'b011110 : 6'b100001;  // D.30
        5'b11111: code_6b = rd ? 6'b010100 : 6'b101011;  // D.31
        
        default:  code_6b = 6'b000000;
    endcase
end

//==============================================================================
// 3B/4B 编码表（简化版）
//==============================================================================
always @(*) begin
    case (data_3b)
        3'b000: code_4b = rd ? 6'b0100 : 6'b1011;  // D.x.0
        3'b001: code_4b = 6'b1001;                 // D.x.1
        3'b010: code_4b = 6'b0101;                 // D.x.2
        3'b011: code_4b = rd ? 6'b0011 : 6'b1100;  // D.x.3
        3'b100: code_4b = rd ? 6'b0010 : 6'b1101;  // D.x.4
        3'b101: code_4b = 6'b1010;                 // D.x.5
        3'b110: code_4b = 6'b0110;                 // D.x.6
        3'b111: code_4b = rd ? 6'b0001 : 6'b1110;  // D.x.7 or K.x.7
        default: code_4b = 4'b0000;
    endcase
end

//==============================================================================
// 计算新的Running Disparity
//==============================================================================
function [0:0] calc_new_rd;
    input [5:0] code6;
    input [3:0] code4;
    input       old_rd;
    
    integer ones_6b, ones_4b, total_ones;
    begin
        // 计算6b中1的个数
        ones_6b = code6[0] + code6[1] + code6[2] + code6[3] + code6[4] + code6[5];
        // 计算4b中1的个数
        ones_4b = code4[0] + code4[1] + code4[2] + code4[3];
        total_ones = ones_6b + ones_4b;
        
        // 如果1的个数 > 5，新RD为正
        // 如果1的个数 < 5，新RD为负
        // 如果1的个数 = 5，RD保持不变
        if (total_ones > 5)
            calc_new_rd = 1'b1;  // 正RD
        else if (total_ones < 5)
            calc_new_rd = 1'b0;  // 负RD
        else
            calc_new_rd = old_rd;  // 保持
    end
endfunction

//==============================================================================
// 主逻辑
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        data_out  <= 10'd0;
        valid_out <= 1'b0;
        rd        <= 1'b0;  // 初始RD为负
    end else begin
        if (valid_in) begin
            // 组合10bit输出 [6b编码][4b编码]
            data_out  <= {code_4b, code_6b};
            valid_out <= 1'b1;
            
            // 更新Running Disparity
            rd <= calc_new_rd(code_6b, code_4b, rd);
        end else begin
            valid_out <= 1'b0;
        end
    end
end

assign running_disp = rd;

endmodule
//==============================================================================
// 简化版 1553B 核心模块 - 修复多驱动问题
//==============================================================================

module simple_1553b_core (
    input  wire        clk,
    input  wire        rst_n,
    
    input  wire [15:0] uart_data,
    input  wire        uart_valid,
    
    output reg  [15:0] aurora_data,
    output reg         aurora_valid,
    
    output reg  [7:0]  status,
    output wire        busy
);

//==============================================================================
// 状态机定义
//==============================================================================
localparam IDLE         = 3'd0;
localparam RECV_CMD     = 3'd1;
localparam RECV_DATA    = 3'd2;
localparam SEND_DATA    = 3'd3;
localparam WAIT         = 3'd4;

//==============================================================================
// 内部信号
//==============================================================================
reg [2:0]  state;
reg [2:0]  next_state;

reg [4:0]  rt_addr;
reg        tr_bit;
reg [4:0]  sub_addr;
reg [4:0]  word_count;

reg [4:0]  recv_counter;     // 接收计数器
reg [4:0]  send_counter;     // 发送计数器
reg [15:0] data_buffer [0:31];
reg [4:0]  wr_ptr;
reg [4:0]  rd_ptr;

reg        cmd_valid;
reg [15:0] last_cmd;

//==============================================================================
// 状态机 - 时序逻辑
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= IDLE;
    else
        state <= next_state;
end

//==============================================================================
// 状态机 - 组合逻辑
//==============================================================================
always @(*) begin
    next_state = state;
    
    case (state)
        IDLE: begin
            if (uart_valid)
                next_state = RECV_CMD;
        end
        
        RECV_CMD: begin
            if (cmd_valid) begin
                if (tr_bit == 1'b0)
                    next_state = RECV_DATA;
                else
                    next_state = SEND_DATA;
            end
        end
        
        RECV_DATA: begin
            if (recv_counter >= word_count)
                next_state = IDLE;
        end
        
        SEND_DATA: begin
            if (send_counter >= word_count)
                next_state = IDLE;
        end
        
        WAIT: begin
            next_state = IDLE;
        end
        
        default: next_state = IDLE;
    endcase
end

//==============================================================================
// 命令字解析
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        rt_addr    <= 5'd0;
        tr_bit     <= 1'b0;
        sub_addr   <= 5'd0;
        word_count <= 5'd0;
        cmd_valid  <= 1'b0;
        last_cmd   <= 16'd0;
    end else begin
        if (state == IDLE && uart_valid) begin
            last_cmd   <= uart_data;
            rt_addr    <= uart_data[15:11];
            tr_bit     <= uart_data[10];
            sub_addr   <= uart_data[9:5];
            word_count <= (uart_data[4:0] == 5'd0) ? 5'd31 : uart_data[4:0];
            cmd_valid  <= 1'b1;
        end else if (state == RECV_CMD) begin
            cmd_valid  <= 1'b0;
        end
    end
end

//==============================================================================
// 数据接收逻辑
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        wr_ptr        <= 5'd0;
        recv_counter  <= 5'd0;
    end else begin
        if (state == IDLE) begin
            recv_counter <= 5'd0;
        end else if (state == RECV_DATA && uart_valid) begin
            data_buffer[wr_ptr] <= uart_data;
            wr_ptr              <= wr_ptr + 1'b1;
            recv_counter        <= recv_counter + 1'b1;
        end
    end
end

//==============================================================================
// 数据发送逻辑
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        aurora_data  <= 16'd0;
        aurora_valid <= 1'b0;
        rd_ptr       <= 5'd0;
        send_counter <= 5'd0;
    end else begin
        if (state == IDLE) begin
            send_counter <= 5'd0;
        end else if (state == SEND_DATA) begin
            if (send_counter < word_count) begin
                aurora_data  <= data_buffer[rd_ptr];
                aurora_valid <= 1'b1;
                rd_ptr       <= rd_ptr + 1'b1;
                send_counter <= send_counter + 1'b1;
            end else begin
                aurora_valid <= 1'b0;
            end
        end else begin
            aurora_valid <= 1'b0;
        end
    end
end

//==============================================================================
// 状态寄存器输出
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        status <= 8'd0;
    end else begin
        status[2:0] <= state;
        status[3]   <= cmd_valid;
        status[4]   <= tr_bit;
        status[7:5] <= 3'd0;
    end
end

//==============================================================================
// 忙碌标志
//==============================================================================
assign busy = (state != IDLE);

endmodule
//==============================================================================
// 顶层模块 - 带ILA调试
//==============================================================================

module top_system_zynq7020 (
    input  wire        sys_clk,
    input  wire        rst_n,
    input  wire        uart_rxd,
    output wire        uart_txd,
    output wire        aurora_tx_p,
    output wire        aurora_tx_n,
    output wire [7:0]  led,
    output wire        busy_led
);

//==============================================================================
// 内部信号
//==============================================================================
wire [7:0]  uart_rx_data;
wire        uart_rx_valid;
wire        uart_rx_busy;

reg  [15:0] data_16bit;
reg         data_16bit_valid;
reg         byte_state;

wire [15:0] b1553_data;
wire        b1553_valid;
wire [7:0]  b1553_status;
wire        b1553_busy;

wire        aurora_busy;
wire [3:0]  aurora_state;
wire [9:0]  enc_data_10;
wire        enc_rd;

//==============================================================================
// 模块例化
//==============================================================================

uart_rx #(
    .CLK_FREQ   (50_000_000),
    .BAUD_RATE  (115200)
) u_uart_rx (
    .clk        (sys_clk),
    .rst_n      (rst_n),
    .uart_rxd   (uart_rxd),
    .rx_data    (uart_rx_data),
    .rx_valid   (uart_rx_valid),
    .rx_busy    (uart_rx_busy),
    .rx_error   ()
);

always @(posedge sys_clk or negedge rst_n) begin
    if (!rst_n) begin
        data_16bit       <= 16'd0;
        data_16bit_valid <= 1'b0;
        byte_state       <= 1'b0;
    end else begin
        data_16bit_valid <= 1'b0;
        if (uart_rx_valid) begin
            if (byte_state == 1'b0) begin
                data_16bit[15:8] <= uart_rx_data;
                byte_state       <= 1'b1;
            end else begin
                data_16bit[7:0]  <= uart_rx_data;
                data_16bit_valid <= 1'b1;
                byte_state       <= 1'b0;
            end
        end
    end
end

simple_1553b_core u_1553b_core (
    .clk          (sys_clk),
    .rst_n        (rst_n),
    .uart_data    (data_16bit),
    .uart_valid   (data_16bit_valid),
    .aurora_data  (b1553_data),
    .aurora_valid (b1553_valid),
    .status       (b1553_status),
    .busy         (b1553_busy)
);

aurora_tx_simple u_aurora_tx (
    .clk          (sys_clk),
    .rst_n        (rst_n),
    .data_in      (b1553_data),
    .data_valid   (b1553_valid),
    .tx_p         (aurora_tx_p),
    .tx_n         (aurora_tx_n),
    .busy         (aurora_busy),
    .state_debug  ({4'd0, aurora_state})
);

assign aurora_state = u_aurora_tx.state;
assign enc_data_10 = u_aurora_tx.u_encoder.data_out;
assign enc_rd = u_aurora_tx.u_encoder.rd;

//==============================================================================
// ILA 例化
//==============================================================================
ila_0 u_ila (
    .clk    (sys_clk),
    .probe0 (uart_rx_data),      // 8bit
    .probe1 (uart_rx_valid),     // 1bit
    .probe2 (data_16bit),        // 16bit
    .probe3 (data_16bit_valid),  // 1bit
    .probe4 (b1553_data),        // 16bit
    .probe5 (b1553_valid),       // 1bit
    .probe6 (aurora_state),      // 4bit
    .probe7 (aurora_tx_p),       // 1bit
    .probe8 (aurora_tx_n),       // 1bit
    .probe9 (enc_data_10),       // 10bit
    .probe10(enc_rd)             // 1bit
);

//==============================================================================
// 输出
//==============================================================================
assign uart_txd = 1'b1;
assign led = {aurora_state, b1553_busy, uart_rx_busy, byte_state, aurora_busy};
assign busy_led = b1553_busy | aurora_busy | uart_rx_busy;

endmodule
//==============================================================================
// UART 接收模块
// 功能：接收串口数据，输出8bit数据流
// 波特率：115200（可配置）
//==============================================================================

module uart_rx #(
    parameter CLK_FREQ = 100_000_000,  // 系统时钟频率 (Hz)
    parameter BAUD_RATE = 115200        // 波特率
)(
    input  wire       clk,
    input  wire       rst_n,
    
    // UART 物理接口
    input  wire       uart_rxd,         // UART 接收引脚
    
    // 数据输出接口
    output reg  [7:0] rx_data,          // 接收到的数据
    output reg        rx_valid,         // 数据有效标志（单时钟脉冲）
    
    // 状态输出
    output reg        rx_busy,          // 正在接收标志
    output reg        rx_error          // 帧错误标志
);

//==============================================================================
// 参数计算
//==============================================================================
localparam CLKS_PER_BIT = CLK_FREQ / BAUD_RATE;
localparam HALF_BIT = CLKS_PER_BIT / 2;

//==============================================================================
// 状态机定义
//==============================================================================
localparam IDLE       = 3'd0;
localparam START_BIT  = 3'd1;
localparam DATA_BITS  = 3'd2;
localparam STOP_BIT   = 3'd3;
localparam ERROR      = 3'd4;

//==============================================================================
// 内部信号
//==============================================================================
reg [2:0]  state;
reg [15:0] clk_count;       // 时钟计数器
reg [2:0]  bit_index;       // 数据位索引 (0-7)
reg [7:0]  rx_data_buf;     // 接收数据缓冲

// UART 输入同步（防止亚稳态）
reg uart_rxd_sync1;
reg uart_rxd_sync2;

//==============================================================================
// 输入信号同步
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        uart_rxd_sync1 <= 1'b1;
        uart_rxd_sync2 <= 1'b1;
    end else begin
        uart_rxd_sync1 <= uart_rxd;
        uart_rxd_sync2 <= uart_rxd_sync1;
    end
end

//==============================================================================
// UART 接收状态机
//==============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state      <= IDLE;
        clk_count  <= 16'd0;
        bit_index  <= 3'd0;
        rx_data    <= 8'd0;
        rx_data_buf <= 8'd0;
        rx_valid   <= 1'b0;
        rx_busy    <= 1'b0;
        rx_error   <= 1'b0;
    end else begin
        rx_valid <= 1'b0;  // 默认拉低
        
        case (state)
            //----------------------------------------------------------
            // IDLE: 等待起始位
            //----------------------------------------------------------
            IDLE: begin
                rx_busy   <= 1'b0;
                rx_error  <= 1'b0;
                clk_count <= 16'd0;
                bit_index <= 3'd0;
                
                // 检测到下降沿（起始位）
                if (uart_rxd_sync2 == 1'b0) begin
                    state    <= START_BIT;
                    rx_busy  <= 1'b1;
                end
            end
            
            //----------------------------------------------------------
            // START_BIT: 验证起始位
            //----------------------------------------------------------
            START_BIT: begin
                if (clk_count == HALF_BIT - 1) begin
                    // 在起始位中间采样
                    if (uart_rxd_sync2 == 1'b0) begin
                        clk_count <= 16'd0;
                        state     <= DATA_BITS;
                    end else begin
                        // 起始位错误
                        state <= ERROR;
                    end
                end else begin
                    clk_count <= clk_count + 1'b1;
                end
            end
            
            //----------------------------------------------------------
            // DATA_BITS: 接收8个数据位
            //----------------------------------------------------------
            DATA_BITS: begin
                if (clk_count == CLKS_PER_BIT - 1) begin
                    clk_count <= 16'd0;
                    
                    // 采样数据位（LSB first）
                    rx_data_buf[bit_index] <= uart_rxd_sync2;
                    
                    if (bit_index == 3'd7) begin
                        // 接收完8位数据
                        bit_index <= 3'd0;
                        state     <= STOP_BIT;
                    end else begin
                        bit_index <= bit_index + 1'b1;
                    end
                end else begin
                    clk_count <= clk_count + 1'b1;
                end
            end
            
            //----------------------------------------------------------
            // STOP_BIT: 接收停止位
            //----------------------------------------------------------
            STOP_BIT: begin
                if (clk_count == CLKS_PER_BIT - 1) begin
                    clk_count <= 16'd0;
                    
                    // 验证停止位
                    if (uart_rxd_sync2 == 1'b1) begin
                        // 接收成功
                        rx_data  <= rx_data_buf;
                        rx_valid <= 1'b1;
                        state    <= IDLE;
                    end else begin
                        // 停止位错误
                        state <= ERROR;
                    end
                end else begin
                    clk_count <= clk_count + 1'b1;
                end
            end
            
            //----------------------------------------------------------
            // ERROR: 错误状态
            //----------------------------------------------------------
            ERROR: begin
                rx_error <= 1'b1;
                state    <= IDLE;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule
